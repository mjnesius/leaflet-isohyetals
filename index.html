<!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8 />
  <title>isohyetals</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

  <!-- Load Leaflet from CDN-->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.2.0"></script>

  <!-- Load Esri Leaflet from CDN -->
  <script src="https://unpkg.com/esri-leaflet@2.1.1"></script>

  <!-- Esri Leaflet GP -->
  <script src="https://unpkg.com/esri-leaflet-gp@2.0.3"></script>

  <!--  d3 contour library ==> creates a d3 global with a contours() method-->
  <!-- d3 example https://github.com/axismaps/contours-->
  <!-- d3 examples https://observablehq.com/collection/@d3/d3-contour -->
  <!-- api ref https://github.com/d3/d3/blob/master/API.md-->
  <script src="https://d3js.org/d3-contour.v1.min.js"></script>

  <!--  turf interpolation library ==> creates a turf global. has featureCollection helper and isobands() method-->
  <!-- 
        var bbox = turf.bbox(geoJSON);// Returns a rectangle 
        var bboxPolygon = turf.bboxPolygon(bbox); // converts bbox into a minimal polygon
        var options = {gridType: 'points', property: 'Total_Rain', units: 'miles'};
        var grid = turf.interpolate(knownPointsFeatureCollection, 0.25, options); //uses IDW, returns a grid based on units/options
        var contourBreaks: inclusiveRange(0, 30, 0.2);
        var lines = turf.isolines(pointGrid, contourBreaks, {zProperty: 'Total_Rain'});
        var curved = turf.bezierSpline(<feature Turf LineString>);
  -->
  <!-- Leaflet.TextPath plugin for contour labels  <script src="leaflet.textpath.js"></script>
     L.geoJson(data, {
        onEachFeature: function (feature, layer) {
            layer.setText(feature.properties.label, {repeat: true, attributes: {fill: 'red'}});
        }
    }).addTo(map);
  -->
  <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
  <script src="leaflet.textpath.js"></script>
        
<style>
    .date {left: 40%;
    vertical-align: top;
    text-align: center;
    position: absolute;
    display: flex;
    align-items: center;
    z-index: 999;
    white-space: pre-wrap;
    margin-top: 10px

}
    body {
      margin:0;
      padding:0;
    }

    #map {
      position: absolute;
      top:0;
      bottom:0;
      right:0;left:0;
    }

    #info-pane {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      padding: 1em;
      background: white;
      max-width: 30%;
    }
    table {
  font-family: arial, sans-serif;
  border-collapse: collapse;
  width: 100%;
}
td, th {
  border: 1px solid #dddddd;
  text-align: left;
  padding: 8px;
}

tr:nth-child(even) {
  background-color: #dddddd;
}
  </style>
</head>
<body>
<div class="date" >
    <font color="white"><b>Start Date  </b> </font>
    <input style="white-space: normal;" type="date" id="start">
    <font color="white"><b>   End Date  </b> </font>
    <input style="white-space: normal;" type="date" id="end">
    <button id="btnRun"style="height: 22px; margin-left: 5px; text-align: center" type="button"> Submit
 </div>
<div id="map"></div>
<div id="info-pane" class="leaflet-bar">
</div>

<script>
  document.getElementById('info-pane').innerHTML = '';

  var map = L.map('map').setView([30.45, -84.31], 13);
  var rainDataDict = {};
  var startDate, endDate, globalGeoJ;
  var gaugeLayer = L.geoJSON().addTo(map);
  var contours = L.geoJSON().addTo(map);
  var gpService = L.esri.GP.service({
    url: "https://cotinter.leoncountyfl.gov/cotinter/rest/services/GeoProcessing/FetchRainData/GPServer/FetchRainData",
    useCors:false,
    async: true,
    timeout: 320000,
    asyncInterval: 3,
  });
  var gpTask = gpService.createTask();

  L.esri.basemapLayer('DarkGray').addTo(map);
  gpTask.setOutputParam('Output_String');
  
  document.getElementById('btnRun').addEventListener("click", () =>{
    document.getElementById('info-pane').innerHTML = 'fetching rain data, this takes 2-3 minutes...';
    rainDataDict = {};
    // note: need to set start hh:mm to 00:00 and enddate hh:mm to 23:59
    var offset = new Date().getTimezoneOffset(document.getElementById("end").valu); //returns diff (number of minutes) between local and utc
    startDate = new Date(document.getElementById("start").value);//.toLocaleString("en-US", { timeZone: "America/New_York" });
    endDate = new Date(document.getElementById("end").value);//.toLocaleString("en-US", { timeZone: "America/New_York" });
    console.log(startDate + " to " + endDate );
    startDate.setMinutes(startDate.getMinutes() + offset);
    endDate.setMinutes(endDate.getMinutes() + offset);
    console.log(startDate + " to " + endDate + " offset: " + offset);
    gpTask.setParam('Start_Date', startDate.valueOf());//1575194400000);
    gpTask.setParam('End_Date', endDate.valueOf());//1575207000000);
    console.log(startDate.valueOf() + " to " + endDate.valueOf());
    if (startDate === "" || endDate === "") {
      alert("Please enter a start and end date")
      return;
    }
    if (startDate > endDate) {
      alert("Please enter a start date that is before or equal to the end date")
      return;
    }
    var taskPromise = new Promise((resolve, reject) => {
      gpTask.run((error, response, raw) => {
        console.log("task ran");
        //   it is pinging this address for the result
        //https://cotinter.leoncountyfl.gov/cotinter/rest/services/GeoProcessing/FetchRainData/GPServer/FetchRainData/jobs/j3ad9081eed61437b88728aa0834b7412?f=json
        if (error) {
          console.log("error: " + error);
          document.getElementById('info-pane').innerHTML = JSON.stringify(error);
          reject(error);
          return;
        }
        document.getElementById('info-pane').innerHTML = "response: " + JSON.stringify(response.value) + "\n\n" + "raw: " + JSON.stringify(raw.value);
        
        resolve(raw.value);
        //the async task then fetches .../results/{setOutputParam}?f=json
        //https://cotinter.leoncountyfl.gov/cotinter/rest/services/GeoProcessing/FetchRainData/GPServer/FetchRainData/jobs/j5d13c9fd386648a3867e1eb675d39889/results/undefined?results%2FOutput_String=undefined&f=json

      })
      return;
    })
    var contourPromise = new Promise ( (resolve, reject) => {
        taskPromise.then(data =>{
        rainDataDict = {...data[0], ...data[1]};
        gaugeLayer.remove();
        console.log("task promise's globalGeoJ " + JSON.stringify(globalGeoJ));
        console.log("task promise's data dict: " + JSON.stringify(rainDataDict));
        gaugeLayer = L.geoJSON(globalGeoJ, {
          onEachFeature: onEachFeature,
          filter: (feature, layer) =>{
            return (rainDataDict[feature.properties.Station_Name] === 0 || rainDataDict[feature.properties.Station_Name] > 0);
            }
          }).addTo(map);
          resolve();  
        });
        
      });
    contourPromise.then(() =>{
      try{
        var bbox = turf.bbox(globalGeoJ);// Returns a rectangle 
        console.log("bbox: " + JSON.stringify(bbox));
        var bboxPolygon = turf.bboxPolygon(bbox); // converts bbox into a minimal polygon
        console.log("bboxPolygon: " + JSON.stringify(bboxPolygon));
        var options = {gridType: 'point', property: 'Total_Rain', units: 'miles'};
        var features = globalGeoJ.features.filter( feature => {
          if (feature.properties.Station_Name in rainDataDict && rainDataDict[feature.properties.Station_Name] !== null ) {
            feature.properties.Total_Rain = rainDataDict[feature.properties.Station_Name];
            return  feature
          };
        });
        
        var featureCollection = turf.featureCollection(features);
        //console.log("featureCollection for interpolate: " + JSON.stringify(decycle(featureCollection)));
        var grid = turf.interpolate(featureCollection, 0.25, options); //uses IDW, returns a grid (featureCollection) based on units/options
        //console.log("idw grid: " + JSON.stringify(grid));
        var contourBreaks= inclusiveRange(0, 30, 0.2);
        var lines = turf.isolines(grid, contourBreaks, {zProperty: 'Total_Rain'}); //returns a FeatureCollection of MultiLineString
        //console.log("lines obj for  bezierSpline: " + JSON.stringify(lines));
        turf.geomEach(lines, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
            //console.log("  featureIndex: " + featureIndex + "  currentGeometry: " + JSON.stringify(currentGeometry));
            currentGeometry['coordinates'] = currentGeometry['coordinates'].map( line => {
              var linestring = turf.lineString(line); //returns a linestring
              smoothedLine = turf.bezierSpline(linestring); //returns a linestring - curved line
              //console.log('  splines smoothedLine: ' + JSON.stringify(smoothedLine));
              return smoothedLine.geometry['coordinates'];
            })
            //console.log("**modified  currentGeometry: " + JSON.stringify(currentGeometry));
          });
        //console.log("modified lines obj after bezierSpline: " + JSON.stringify(lines));
        contours.remove(); 
        contours = L.geoJSON(lines, {
          onEachFeature: function (feature, layer) {
            layer.setText(("         " + feature.properties['Total_Rain'].toFixed(2) + "         "), {repeat: true, attributes: {fill: 'white', 'font-weight': 'bold', 'font-size': '22','dx': '400%'}});
          },
          style: {
            color: "#ff0000",
            "weight": 5
          }
        }).addTo(map);
        //contours = L.polyline(lines, {color: 'red'}).addTo(map);
      } catch(e) {
        console.error(e);
      }
      
    })
  });
  const geojStationFeatures =  fetch("../stationsWGS84.json")
    .then((res) => res.json())
    .then( geojStationFeatures =>{
        console.log(geojStationFeatures);
        globalGeoJ = geojStationFeatures
        //var gaugeLayer = L.geoJSON().addTo(map);
        //var geojson = L.geoJSON(geojStationFeatures);
        gaugeLayer = L.geoJSON(geojStationFeatures, {
         onEachFeature: onEachFeature
       }).addTo(map);
        
    });
    
  function onEachFeature(feature, layer) {
      //console.log("on each feature, layer: " + JSON.stringify(layer));
      //console.log("on each feature, feature: " + JSON.stringify(feature));
    if (Object.keys(rainDataDict).length > 0 && layer.feature.properties) {
      feature.properties.Total_Rain = (rainDataDict[feature.properties.Station_Name] || 
        rainDataDict[feature.properties.Station_Name] === 0) ? 
          + rainDataDict[feature.properties.Station_Name].toFixed(2) : null;
      console.log(feature.properties.Station_Name + "'s new rain total: " + rainDataDict[feature.properties.Station_Name] + " == " + feature.properties.Total_Rain)
      var Date_Range = startDate + " to " + endDate;
      var popup = `<h3>${feature.properties.Station_Name}</h2>
              <table>
                <tr>
                  <th><b>Total_Rain</b></th>
                  <th>${!(feature.properties.Total_Rain === null) ? (feature.properties.Total_Rain + '"') : "null"}</th>
                </tr>
                <tr>
                  <td><b>NWF_ID</b></td>
                  <td>${feature.properties.NWF_ID ? feature.properties.NWF_ID : "null"}</td>
                </tr>
                <tr>
                  <td><b>SiteID</b></td>
                  <td>${feature.properties.SiteID ? layer.feature.properties.SiteID : "null"}</td>
                </tr>
                <tr>
                  <td><b>Date_Range</b></td>
                  <td>${Date_Range}</td>
                </tr>
              </table>`
      layer.bindPopup(popup);
    }
    else if (layer.feature.properties) {
      var popup = `<h3>${layer.feature.properties.Station_Name}</h2>
              <table>
                <tr>
                  <th><b>Total_Rain</b></th>
                  <th>${layer.feature.properties.Total_Rain ? layer.feature.properties.Total_Rain : "null"}</th>
                </tr>
                <tr>
                  <td><b>NWF_ID</b></td>
                  <td>${layer.feature.properties.NWF_ID ? layer.feature.properties.NWF_ID : "null"}</td>
                </tr>
                <tr>
                  <td><b>SiteID</b></td>
                  <td>${layer.feature.properties.SiteID ? layer.feature.properties.SiteID : "null"}</td>
                </tr>
              </table>`
      layer.bindPopup(popup);
    }
  }

  function inclusiveRange(start, end, step) {
    return Array.from(Array.from(Array(Math.ceil((end-start+1)/step)).keys()), x => start+ x*step);
  }
  function decycle(obj, stack = []) { //https://stackoverflow.com/questions/9382167/serializing-object-that-contains-cyclic-object-value
    if (!obj || typeof obj !== 'object')
        return obj;
    
    if (stack.includes(obj))
        return null;

    let s = stack.concat([obj]);

    return Array.isArray(obj)
        ? obj.map(x => decycle(x, s))
        : Object.fromEntries(
            Object.entries(obj)
                .map(([k, v]) => [k, decycle(v, s)]));
}

</script>

</body>
</html>

      <!-- /* const oneRainGetDict = {
      "STREETS AND DRAINAGE (CITY ID# 300)": ["5", "1"],
      "JAKE GAITHER GOLF COURSE (CITY ID# 500)": ["2", "1"],
      "TALLAHASSEE CITY HALL (CITY ID# 100)": ["4", "1"],
      "SENIOR CITIZEN CENTER (CITY ID# 200)": ["6", "1"],
      "SOUTHWOOD GOLF COURSE (CITY ID# 600)": ["1", "1"],
      "HILAMAN GOLF COURSE (CITY ID# 400)": ["3", "1"]
    }

    const nwfwmdGetDict = {
        "CAPITAL CIRCLE, OLD LANDFILL": 760965,
        "LAKE JACKSON FACILITY": 762684,
        "FOREST SERVICE WORK CENTER - BLOXHAM CUTOFF": 761627,
        "MICCOSUKEE PARK": 761626,
        "LAKE JACKSON - MILLER LANDING ROAD": 761623,
        "LAKE IAMONIA OUTFALL @ MERIDIAN RD": 761595,
        "APALACHEE REGIONAL PARK": 761596,
        "BANNERMAN ROAD NEAR THOMASVILLE RD": 761600,
        "COMMONWEALTH BLVD, WEST - LEON COUNTY": 761604,
        "FT BRADEN RAINFALL 827": 761634,
        "LAKE KANTURK OUTFALL @ CENTERVILLE RD": 761637,
        "LAKE IAMONIA": 761547,
        "HERRON STEEL SITE, SILVER LAKE RD.": 761607,
        "ABUNDANT LIFE FELLOWSHIP": 761601,
        "JOHN KNOX POND, MEGGINNIS TRIBUTARY": 760962,
        "WEMBLEY WAY, EASTGATE NEIGHBORHOOD": 761613,
        "STILL CREEK @ CAPITOLA RD": 761783,
        "MILITARY TRAIL NEAR NATURAL BRIDGE RD.": 761608,
        "TUCK PROPERTY, N. CENTERVILLE RD.": 761628,
        "CHOWKEEBIN NENE NEAR MAGNOLIA DR.": 761602,
        "WAKULLA SPRINGS STATE PARK": 761625,
        "ST. MARKS RIVER @ SAN MARCOS DE APALACHEE S.P.": 762890,
        "RIVER SINK TOWER - RAIN": 762899,
        "District HQ Rain": 760892
      } */ -->


